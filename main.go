package main

import (
	"fmt"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const dirtyTrackingTpl = `package {{.GoPackageName}}

import (
	"google.golang.org/protobuf/proto"
)

type DirtyCallback func(field int32)

type DirtyTracker interface {
	IsDirty(field int32) bool
	SetDirty(field int32)
	ResetDirty(field int32)
	ResetAllDirty()
	SetOnDirtyCallback(callback DirtyCallback)
}

{{range .Messages}}
type dirty{{.GoIdent.GoName}} struct {
	{{.GoIdent.GoName}}
	dirtyFields map[int32]bool
	onDirtyCallback DirtyCallback
}

{{range .Fields}}
func (x *dirty{{.GoIdent.GoName}}) {{.GoName}}() {{fieldGoType .Desc}} {
	return x.{{.GoName}}
}

func (x *dirty{{.GoIdent.GoName}}) Set{{.GoName}}(value {{fieldGoType .Desc}}) {
	if x.{{.GoName}}() != value {
		x.{{.GoName}} = value
		x.setDirty({{.Desc.Number}})
	}
}
{{end}}

func (x *dirty{{.GoIdent.GoName}}) IsDirty(field int32) bool {
	return x.dirtyFields[field]
}

func (x *dirty{{.GoIdent.GoName}}) SetDirty(field int32) {
	x.dirtyFields[field] = true
}

func (x *dirty{{.GoIdent.GoName}}) ResetDirty(field int32) {
	delete(x.dirtyFields, field)
}

func (x *dirty{{.GoIdent.GoName}}) ResetAllDirty() {
	x.dirtyFields = make(map[int32]bool)
}

func (x *dirty{{.GoIdent.GoName}}) SetOnDirtyCallback(callback DirtyCallback) {
	x.onDirtyCallback = callback
}

func (x *dirty{{.GoIdent.GoName}}) setDirty(field int32) {
	x.dirtyFields[field] = true
	if x.onDirtyCallback != nil {
		x.onDirtyCallback(field)
	}
}

{{end}}`

func lowerCamelCase(s string) string {
	if s == "" {
		return s
	}
	return strings.ToLower(string(s[0])) + s[1:]
}

func main() {
	protogen.Options{
		ParamFunc: flags,
	}.Run(func(gen *protogen.Plugin) error {
		tpl, err := template.New("dirtyTracking").Funcs(template.FuncMap{
			"fieldGoType":    fieldGoType,
			"lowerCamelCase": lowerCamelCase,
		}).Parse(dirtyTrackingTpl)
		if err != nil {
			return err
		}

		for _, file := range gen.Files {
			if file.Generate {
				generateFile(gen, file, tpl)
			}
		}
		return nil
	})
}

func flags(name, params string) error {
	return nil
}

func generateFile(gen *protogen.Plugin, file *protogen.File, tpl *template.Template) {
	g := gen.NewGeneratedFile(file.GeneratedFilenamePrefix+".dirty.pb.go", file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-dirty. DO NOT EDIT.")
	////g.P("// versions:")
	////g.P("// - protoc-gen-go ", protogen.Version)
	////g.P("// - protoc        ", protogen.ProtocVersion)
	//g.P()
	//
	//g.P("package ", file.GoPackageName)
	//g.P()

	funcMap := template.FuncMap{
		"fieldGoType": func(desc protoreflect.FieldDescriptor) string {
			return fieldGoType(g, desc)
		},
	}

	if err := tpl.Funcs(funcMap).Execute(g, file); err != nil {
		panic(err)
	}
}

func fieldGoType(g *protogen.GeneratedFile, desc protoreflect.FieldDescriptor) string {
	switch desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.EnumKind:
		enumIdent := protogen.GoIdent{
			GoName:       string(desc.Enum().Name()),
			GoImportPath: protogen.GoImportPath(desc.Enum().ParentFile().Path()),
		}
		return g.QualifiedGoIdent(enumIdent)
	case protoreflect.Fixed32Kind, protoreflect.Int32Kind, protoreflect.Sfixed32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind:
		return "int32"
	case protoreflect.Fixed64Kind, protoreflect.Int64Kind, protoreflect.Sfixed64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind:
		return "int64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		msgIdent := protogen.GoIdent{
			GoName:       string(desc.Message().Name()),
			GoImportPath: protogen.GoImportPath(desc.Message().ParentFile().Path()),
		}
		return "*" + g.QualifiedGoIdent(msgIdent)
	case protoreflect.GroupKind:
		panic("GroupKind not supported")
	}

	if desc.Cardinality() == protoreflect.Repeated {
		elemType := fieldGoType(g, desc)
		return "[]" + elemType
	}

	if desc.IsMap() {
		keyType := fieldGoType(g, desc.MapKey())
		valueType := fieldGoType(g, desc.MapValue())
		return "map[" + keyType + "]" + valueType
	}

	panic(fmt.Sprintf("unknown field type: %v", desc.Kind()))
}
